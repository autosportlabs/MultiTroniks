 /*    Vaccuum Switch Controller    							*/     1 
/*    Revision 1.0 5/5/98          							*/     2 
/*    Revision 1.1 6/3/98       In function 'mode' the led     3 
will only light when it sees 6 complete transistions not 5  */     4 
      5 
     6 
#include <16C71.H>     7 
 //////// Standard Header file for the PIC16C71 device ////////  2049 
#device PIC16C71  2050 
#nolist  2051N
/////////////////////////////// I/O definitions for INPUT() and OUTPUT_xxx()  2052N
#define PIN_A0  40  2053N
#define PIN_A1  41  2054N
#define PIN_A2  42  2055N
#define PIN_A3  43  2056N
#define PIN_A4  44  2057N
  2058N
#define PIN_B0  48  2059N
#define PIN_B1  49  2060N
#define PIN_B2  50  2061N
#define PIN_B3  51  2062N
#define PIN_B4  52  2063N
#define PIN_B5  53  2064N
#define PIN_B6  54  2065N
#define PIN_B7  55  2066N
  2067N
/////////////////////////////// Useful defines  2068N
#define FALSE 0  2069N
#define TRUE 1  2070N
  2071N
#define BYTE int  2072N
#define BOOLEAN short int  2073N
  2074N
#define getc getch  2075N
#define getchar getch  2076N
#define puts(s) {printf(s); putchar(13); putchar(10);}  2077N
#define putc putchar  2078N
  2079N
/////////////////////////////// Constants used for RESTART_CAUSE()  2080N
#define WDT_FROM_SLEEP  0  2081N
#define WDT_TIMEOUT     8  2082N
#define MCLR_FROM_SLEEP 16  2083N
#define NORMAL_POWER_UP 24  2084N
/////////////////////////////// Constants used for SETUP_COUNTERS()  2085N
#define RTCC_INTERNAL   0  2086N
#define RTCC_EXT_L_TO_H 32  2087N
#define RTCC_EXT_H_TO_L 48  2088N
#define RTCC_DIV_2      0  2089N
#define RTCC_DIV_4      1  2090N
#define RTCC_DIV_8      2  2091N
#define RTCC_DIV_16     3  2092N
#define RTCC_DIV_32     4  2093N
#define RTCC_DIV_64     5  2094N
#define RTCC_DIV_128    6  2095N
#define RTCC_DIV_256    7  2096N
#define WDT_18MS        8  2097N
#define WDT_36MS        9  2098N
#define WDT_72MS       10  2099N
#define WDT_144MS      11  2100N
#define WDT_288MS      12  2101N
#define WDT_576MS      13  2102N
#define WDT_1152MS     14  2103N
#define WDT_2304MS     15  2104N
#define L_TO_H              0x40  2105N
#define H_TO_L                 0  2106N
  2107N
#define RTCC_ZERO           0x0B20    // Used for ENABLE/DISABLE INTERRUPTS  2108N
#define INT_RTCC            0x0B20    // Used for ENABLE/DISABLE INTERRUPTS  2109N
#define RB_CHANGE           0x0B08    // Used for ENABLE/DISABLE INTERRUPTS  2110N
#define INT_RB              0x0B08    // Used for ENABLE/DISABLE INTERRUPTS  2111N
#define EXT_INT             0x0B10    // Used for ENABLE/DISABLE INTERRUPTS  2112N
#define INT_EXT             0x0B10    // Used for ENABLE/DISABLE INTERRUPTS  2113N
  2114N
#define GLOBAL              0x0B80    // Used for ENABLE/DISABLE INTERRUPTS  2115N
///////////////////////////////////// Constants used for SETUP_ADC_PORTS()  2116N
#define NO_ANALOGS             3  2117N
#define ALL_ANALOG             0  2118N
#define ANALOG_RA3_REF         1  2119N
#define RA0_RA1_ANALOG         2  2120N
///////////////////////////////////// Constants used for SETUP_ADC()  2121N
#define ADC_OFF                0  2122N
#define ADC_CLOCK_DIV_2        1  2123N
#define ADC_CLOCK_DIV_8     0x41  2124N
#define ADC_CLOCK_DIV_32    0x81  2125N
#define ADC_CLOCK_INTERNAL  0xc1  2126N
  2127N
#define ADC_DONE          0x8C40    // Used for ENABLE/DISABLE INTERRUPTS  2128N
#define INT_ADC           0x8C40    // Used for ENABLE/DISABLE INTERRUPTS  2129N
  2130N
#list  2131 
    7 
     8 
			//application specific definitions     9 
#define min_vac 20    10 
#define vac_solonoid PIN_B0		//input pc calling for vacuum    11 
#define vacuum_sense PIN_B1		//output component confirmation to pc    12 
#define vacuum_sol_drive PIN_B2		//output to turn vac sol on    13 
#define vac_generator PIN_B6		//output to turn vac gen on    14 
    15 
			//global definitions    16 
int baseline,time;    17 
    18 
    19 
    20 
#fuses XT,NOPROTECT,NOWDT    21 
#use DELAY(clock=4000000)    22 
#use Standard_IO(A)    23 
#use Standard_IO(B)    24 
    25 
    26 
void INITIALIZE()			//startup    27 
{    28 
	//set_tris_a(0x0F);		//=b'1111'    29 
	//set_tris_b(0xFF);		//=b'11111001'    30 
	setup_port_a(RA0_RA1_ANALOG);	//set up a2d    31 
	setup_adc(ADC_CLOCK_DIV_2);    32 
	set_adc_channel(0);    33 
	baseline = 100;    34 
	time = 32;			//each 16 is one second delay    35 
	output_high(vacuum_sense);    36 
	delay_ms(400);    37 
	output_low(vacuum_sense);    38 
	delay_ms(400);    39 
	output_high(vacuum_sense);    40 
	delay_ms(400);    41 
	output_low(vacuum_sense);    42 
	delay_ms(400);    43 
	output_high(vacuum_sense);    44 
	delay_ms(400);    45 
	output_low(vacuum_sense);    46 
}    47 
    48 
    49 
void SAMPLING()    50 
{	int sample;    51 
    52 
	output_high(vac_generator);    53 
	do    54 
	{	delay_us(400);				//400sets sample rate at 2500Hz    55 
		sample = read_adc()/2;			//takes average of two samples    56 
		delay_us(400);    57 
		sample = sample + read_adc()/2;    58 
		if (sample < baseline) output_low(vacuum_sense);    59 
		else output_high(vacuum_sense);    60 
	} while (!input(vac_solonoid));			//is solinoid on?    61 
	if (sample > baseline)     62 
	{	    63 
 		do    64 
		{delay_us(400);				//sets sample rate at 2500Hz    65 
		sample = read_adc()/2;			//takes average of two samples    66 
		delay_us(400);    67 
		sample = sample + read_adc()/2;    68 
		} while (sample > min_vac);		//is vacuum low?    69 
 		output_low(vacuum_sense);    70 
	}    71 
	setup_counters(rtcc_internal,rtcc_div_256);	//sets up 2 second delay for generator    72 
	set_rtcc(1);    73 
	time = 0;    74 
	return;    75 
}    76 
    77 
    78 
void READ_BASELINE()    79 
{	int x;    80 
	long temp;    81 
    82 
	output_high(vac_generator);    83 
	output_high(vacuum_sol_drive);    84 
	delay_ms(300);    85 
	baseline = 0;    86 
	temp = 0;    87 
	for (x = 0;x != 8;x++){    88 
		delay_ms(2);    89 
		temp = temp + read_adc();    90 
		}    91 
	temp = temp / 8;				//take average of 8 samples    92 
	baseline = 4 + temp + (211 - temp)/8;		//baseline1 = 4 + baseline0 +.125*(maxvac-baseline0)    93 
	output_low(vacuum_sense);    94 
	output_low(vac_generator);    95 
	output_low(vacuum_sol_drive);    96 
	return;    97 
}    98 
    99 
   100 
void MODE()						//setup baseline or normal sample mode?   101 
{	int test,logic;   102 
   103 
	logic = 1;   104 
	test = 1;   105 
	setup_counters(rtcc_internal,rtcc_div_8);   106 
	set_rtcc(68);   107 
	do						//test to see 3 changes in state   108 
	{	if (input(vac_solonoid) == logic)   109 
		{	test = test + 1;   110 
			if (logic == 0) logic = 1;   111 
			else logic = 0;   112 
		}   113 
	} while (get_rtcc() > 67);			//check mode for 1.5ms   114 
	if (test == 6) output_high(vacuum_sense);   115 
	if (test >= 4) READ_BASELINE();			//if one or more toggle then goto setup   116 
	else SAMPLING();   117 
	return;   118 
}   119 
   120 
	   121 
TIMEOFF()						//check to see if 2 seconds has elapsed	   122 
{	if (time == 32) return;				//before the vacuum gen will be shut off   123 
	else   124 
	{	time++;   125 
		set_rtcc(1);   126 
		if (time == 32) output_low(vac_generator);   127 
		return;   128 
	}   129 
}   130 
   131 
MAIN()   132 
{	INITIALIZE();   133 
	do   134 
	{   135 
		if (!input(vac_solonoid)) MODE();   136 
		if (get_rtcc() == 0) TIMEOFF();   137 
	} while(true);	   138 
}   139 
