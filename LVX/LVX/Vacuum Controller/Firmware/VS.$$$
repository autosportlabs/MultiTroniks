 /*    Vaccuum Switch Controller    							*/     1 
/*    Revision 1.0 5/5/98          							*/     2 
/*    Revision 1.1 6/3/98       In function 'mode' the led     3 
/*		will only light when it sees 6 complete transistions not 5  */     4 
/*	  Revision 1.2 2/18/99		Made more sensitive for small parts	*/     5 
      6 
     7 
#include <16C71.H>     8 
 //////// Standard Header file for the PIC16C71 device ////////  2049 
#device PIC16C71  2050 
#nolist  2051N
/////////////////////////////// I/O definitions for INPUT() and OUTPUT_xxx()  2052N
#define PIN_A0  40  2053N
#define PIN_A1  41  2054N
#define PIN_A2  42  2055N
#define PIN_A3  43  2056N
#define PIN_A4  44  2057N
  2058N
#define PIN_B0  48  2059N
#define PIN_B1  49  2060N
#define PIN_B2  50  2061N
#define PIN_B3  51  2062N
#define PIN_B4  52  2063N
#define PIN_B5  53  2064N
#define PIN_B6  54  2065N
#define PIN_B7  55  2066N
  2067N
/////////////////////////////// Useful defines  2068N
#define FALSE 0  2069N
#define TRUE 1  2070N
  2071N
#define BYTE int  2072N
#define BOOLEAN short int  2073N
  2074N
#define getc getch  2075N
#define getchar getch  2076N
#define puts(s) {printf(s); putchar(13); putchar(10);}  2077N
#define putc putchar  2078N
  2079N
/////////////////////////////// Constants used for RESTART_CAUSE()  2080N
#define WDT_FROM_SLEEP  0  2081N
#define WDT_TIMEOUT     8  2082N
#define MCLR_FROM_SLEEP 16  2083N
#define NORMAL_POWER_UP 24  2084N
/////////////////////////////// Constants used for SETUP_COUNTERS()  2085N
#define RTCC_INTERNAL   0  2086N
#define RTCC_EXT_L_TO_H 32  2087N
#define RTCC_EXT_H_TO_L 48  2088N
#define RTCC_DIV_2      0  2089N
#define RTCC_DIV_4      1  2090N
#define RTCC_DIV_8      2  2091N
#define RTCC_DIV_16     3  2092N
#define RTCC_DIV_32     4  2093N
#define RTCC_DIV_64     5  2094N
#define RTCC_DIV_128    6  2095N
#define RTCC_DIV_256    7  2096N
#define WDT_18MS        8  2097N
#define WDT_36MS        9  2098N
#define WDT_72MS       10  2099N
#define WDT_144MS      11  2100N
#define WDT_288MS      12  2101N
#define WDT_576MS      13  2102N
#define WDT_1152MS     14  2103N
#define WDT_2304MS     15  2104N
#define L_TO_H              0x40  2105N
#define H_TO_L                 0  2106N
  2107N
#define RTCC_ZERO           0x0B20    // Used for ENABLE/DISABLE INTERRUPTS  2108N
#define INT_RTCC            0x0B20    // Used for ENABLE/DISABLE INTERRUPTS  2109N
#define RB_CHANGE           0x0B08    // Used for ENABLE/DISABLE INTERRUPTS  2110N
#define INT_RB              0x0B08    // Used for ENABLE/DISABLE INTERRUPTS  2111N
#define EXT_INT             0x0B10    // Used for ENABLE/DISABLE INTERRUPTS  2112N
#define INT_EXT             0x0B10    // Used for ENABLE/DISABLE INTERRUPTS  2113N
  2114N
#define GLOBAL              0x0B80    // Used for ENABLE/DISABLE INTERRUPTS  2115N
///////////////////////////////////// Constants used for SETUP_ADC_PORTS()  2116N
#define NO_ANALOGS             3  2117N
#define ALL_ANALOG             0  2118N
#define ANALOG_RA3_REF         1  2119N
#define RA0_RA1_ANALOG         2  2120N
///////////////////////////////////// Constants used for SETUP_ADC()  2121N
#define ADC_OFF                0  2122N
#define ADC_CLOCK_DIV_2        1  2123N
#define ADC_CLOCK_DIV_8     0x41  2124N
#define ADC_CLOCK_DIV_32    0x81  2125N
#define ADC_CLOCK_INTERNAL  0xc1  2126N
  2127N
#define ADC_DONE          0x8C40    // Used for ENABLE/DISABLE INTERRUPTS  2128N
#define INT_ADC           0x8C40    // Used for ENABLE/DISABLE INTERRUPTS  2129N
  2130N
#list  2131 
    8 
     9 
			//application specific definitions    10 
#define min_vac 20    11 
#define vac_solonoid PIN_B0		//input pc calling for vacuum    12 
#define vacuum_sense PIN_B1		//output component confirmation to pc    13 
#define vacuum_sol_drive PIN_B2		//output to turn vac sol on    14 
#define vac_generator PIN_B6		//output to turn vac gen on    15 
    16 
			//global definitions    17 
int baseline,time;    18 
    19 
    20 
    21 
#fuses XT,NOPROTECT,NOWDT    22 
#use DELAY(clock=4000000)    23 
#use Standard_IO(A)    24 
#use Standard_IO(B)    25 
    26 
    27 
void INITIALIZE()			//startup    28 
{    29 
	//set_tris_a(0x0F);		//=b'1111'    30 
	//set_tris_b(0xFF);		//=b'11111001'    31 
	setup_port_a(RA0_RA1_ANALOG);	//set up a2d    32 
	setup_adc(ADC_CLOCK_DIV_2);    33 
	set_adc_channel(0);    34 
	baseline = 100;    35 
	time = 32;			//each 16 is one second delay    36 
	output_high(vacuum_sense);    37 
	delay_ms(400);    38 
	output_low(vacuum_sense);    39 
	delay_ms(400);    40 
	output_high(vacuum_sense);    41 
	delay_ms(400);    42 
	output_low(vacuum_sense);    43 
	delay_ms(400);    44 
	output_high(vacuum_sense);    45 
	delay_ms(400);    46 
	output_low(vacuum_sense);    47 
}    48 
    49 
    50 
void SAMPLING()    51 
{	int sample;    52 
    53 
	output_high(vac_generator);    54 
	do    55 
	{	delay_us(400);				//400sets sample rate at 2500Hz    56 
		sample = read_adc()/2;			//takes average of two samples    57 
		delay_us(400);    58 
		sample = sample + read_adc()/2;    59 
		if (sample < baseline) output_low(vacuum_sense);    60 
		else output_high(vacuum_sense);    61 
	} while (!input(vac_solonoid));			//is solinoid on?    62 
	if (sample > baseline)     63 
	{	    64 
 		do    65 
		{delay_us(400);				//sets sample rate at 2500Hz    66 
		sample = read_adc()/2;			//takes average of two samples    67 
		delay_us(400);    68 
		sample = sample + read_adc()/2;    69 
		} while (sample > min_vac);		//is vacuum low?    70 
 		output_low(vacuum_sense);    71 
	}    72 
	setup_counters(rtcc_internal,rtcc_div_256);	//sets up 2 second delay for generator    73 
	set_rtcc(1);    74 
	time = 0;    75 
	return;    76 
}    77 
    78 
    79 
void READ_BASELINE()    80 
{	int x;    81 
	long temp;    82 
    83 
	output_high(vac_generator);    84 
	output_high(vacuum_sol_drive);    85 
	delay_ms(400);							//rev 1.2... was 300ms    86 
	baseline = 0;    87 
	temp = 0;    88 
	for (x = 0;x != 8;x++){    89 
		delay_ms(2);    90 
		temp = temp + read_adc();    91 
		}    92 
	temp = temp / 8;				//take average of 8 samples    93 
	baseline = temp + (211 - temp)/8;		//rev 1.2... baseline1 = baseline0 +.125*(maxvac-baseline0)    94 
	output_low(vacuum_sense);				//was baseline1 = 4 + baseline0 +.125*(maxvac-baseline0)    95 
	output_low(vac_generator);    96 
	output_low(vacuum_sol_drive);    97 
	return;    98 
}    99 
   100 
   101 
void MODE()						//setup baseline or normal sample mode?   102 
{	int test,logic;   103 
   104 
	logic = 1;   105 
	test = 1;   106 
	setup_counters(rtcc_internal,rtcc_div_8);   107 
	set_rtcc(68);   108 
	do						//test to see 3 changes in state   109 
	{	if (input(vac_solonoid) == logic)   110 
		{	test = test + 1;   111 
			if (logic == 0) logic = 1;   112 
			else logic = 0;   113 
		}   114 
	} while (get_rtcc() > 67);			//check mode for 1.5ms   115 
	if (test == 6) output_high(vacuum_sense);   116 
	if (test >= 4) READ_BASELINE();			//if one or more toggle then goto setup   117 
	else SAMPLING();   118 
	return;   119 
}   120 
   121 
	   122 
TIMEOFF()						//check to see if 2 seconds has elapsed	   123 
{	if (time == 32) return;				//before the vacuum gen will be shut off   124 
	else   125 
	{	time++;   126 
		set_rtcc(1);   127 
		if (time == 32) output_low(vac_generator);   128 
		return;   129 
	}   130 
}   131 
   132 
MAIN()   133 
{	INITIALIZE();   134 
	do   135 
	{   136 
		if (!input(vac_solonoid)) MODE();   137 
		if (get_rtcc() == 0) TIMEOFF();   138 
	} while(true);	   139 
}   140 
